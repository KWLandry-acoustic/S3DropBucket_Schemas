{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "Master S3DropBucket Customer Config Schema",
  "description": "S3DropBucket Master Customer Config Schema",
  "type": "object",
  "required": [
    "selectivelogging",
    "Customer",
    "format",
    "separator",
    "updates",
    "updatetype",
    "targetupdate",
    "updatemaxrows",
    "transforms"
  ],
  "properties": {
    "Customer": {
      "type": "string",
      "description": "DataFlow Name - Best Practice 'CustomerName_DataflowName_'. Must end with an underscore '_' and be the last underscore in the name. Eg: Customer_DataFlow1_09-10-2024-dataseries99.json",
      "default": "CustomerDataFlow1_",
      "minLength": 3
    },
    "selectivelogging": {
      "type": "string",
      "description": "Override Selective Logging for this Customers DataFlow",
      "default": "",
      "minLength": 0
    },
    "format": {
      "type": "string",
      "description": "Inbound data is in the format of CSV or JSON data",
      "default": "json",
      "minLength": 3,
      "enum": [
        "json",
        "csv"
      ]
    },
    "separator": {
      "type": "string",
      "description": "Inbound data has this seperator (When different than the default for that type, JSON should use the default of '\\n')",
      "default": "\n",
      "minLength": 1,
      "enum": [
        ",",
        "|",
        "\n"
      ]
    },
    "targetupdate": {
      "type": "string",
      "description": "The data is to be written to Connect or Campaign",
      "minLength": 7,
      "maxLength": 8,
      "default": "Connect",
      "enum": [
        "Campaign",
        "Connect"
      ]
    },
    "updates": {
      "type": "string",
      "description": "Inbound data is made up of small continuous updates (Singular) or arrives in bulk as multiple updates (Multiple).",
      "minLength": 8,
      "maxLength": 8,
      "default": "Multiple",
      "enum": [
        "Singular",
        "Multiple"
      ]
    },
    "updatemaxrows": {
      "type": "number",
      "description": "Emit a Safety Warning when the rows of any single inbound update exceeds this value",
      "default": 10000,
      "minimum": 1
    },
    "updatetype": {
      "type": "string",
      "description": "The dataflow update-type to be used for the Connect or Campaign Org. Update as Relational, DBKeyed, DBNonKeyed, ReferenceSet, CreateUpdateContacts",
      "minLength": 7,
      "maxLength": 14,
      "default": "Relational",
      "enum": [
        "Relational",
        "DBKeyed",
        "DBNonKeyed",
        "ReferenceSet",
        "CreateUpdateContacts"
      ]
    },
    "lookupkeys": {
      "type": "array",
      "description": "When updatetype is DBNonKeyed, what are the LookUp Keys to be used to update records (use a comma seperated list between the brackets) ",
      "minLength": 0,
      "maxLength": 50,
      "default": "[]"
    },
    "listid": {
      "type": "string",
      "description": "When updatetype is Relational, DBKeyed, or DBNonKeyed what is the target listid to be updated",
      "minLength": 0,
      "default": ""
    },
    "listname": {
      "type": "string",
      "minLength": 0,
      "default": ""
    },
    "pod": {
      "type": "string",
      "description": "When updatetype is Relational, DBKeyed, or DBNonKeyed what is the Acoustic POD number for the Customers Org.",
      "optional": true,
      "minLength": 0,
      "maxLength": 1,
      "enum": [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B"
      ],
      "default": "0"
    },
    "region": {
      "type": "string",
      "description": "When updatetype is Relational, DBKeyed, or DBNonKeyed what is the Acoustic Region for the Customers Org.",
      "default": "us",
      "minLength": 0,
      "maxLength": 2,
      "enum": [
        "us",
        "eu",
        "ap",
        "ca"
      ]
    },
    "clientid": {
      "type": "string",
      "description": "When updatetype is Relational, DBKeyed, or DBNonKeyed what is the Acoustic App Access ClientId for the Customers Org.",
      "minLength": 0,
      "default": ""
    },
    "clientsecret": {
      "type": "string",
      "description": "When updatetype is Relational, DBKeyed, or DBNonKeyed what is the Acoustic App Access ClientSecret for the Customers Org.",
      "minLength": 0,
      "default": ""
    },
    "refreshtoken": {
      "type": "string",
      "description": "When updatetype is Relational, DBKeyed, or DBNonKeyed what is the Acoustic App Access RefreshToken for the Customers Org.",
      "minLength": 0,
      "default": ""
    },
    "datasetid": {
      "type": "string",
      "description": "When 'updatetype' is ReferenceSet or CreateUpdateContacts what is the target datasetid to be updated",
      "minLength": 0,
      "default": ""
    },
    "subscriptionid": {
      "type": "string",
      "description": "When 'updatetype' is ReferenceSet or CreateUpdateContacts what is the Customers SubscriptionId of their Connect Org",
      "minLength": 0,
      "default": ""
    },
    "x_api_key": {
      "type": "string",
      "description": "When 'updatetype' is ReferenceSet or CreateUpdateContacts what is the Connect API x_api_key of their Connect Org (currently its the same value for all Connect Orgs)",
      "minLength": 0,
      "default": ""
    },
    "x_acoustic_region": {
      "type": "string",
      "description": "When 'updatetype' is ReferenceSet or CreateUpdateContacts then specify the Customers Connect Org. Region Id",
      "default": "us-east-1",
      "enum": [
        "us-east-1",
        "us-east-2",
        "us-west-1",
        "us-west-2",
        "af-south-1",
        "ap-east-1",
        "ap-south-1",
        "ap-south-2",
        "ap-southeast-1",
        "ap-southeast-2",
        "ap-southeast-3",
        "ap-southeast-4",
        "ap-northeast-1",
        "ap-northeast-2",
        "ap-northeast-3",
        "ca-central-1",
        "eu-central-1",
        "eu-central-2",
        "eu-north-1",
        "eu-south-1",
        "eu-south-2",
        "eu-west-1",
        "eu-west-2",
        "eu-west-3",
        "il-central-1",
        "me-central-1",
        "me-south-1",
        "sa-east-1"
      ],
      "minLength": 0
    },
    "responseBroker": {
      "type": "object",
      "description": "(Experimental) Response Broker Configuration",
      "required": [
        "destination",
        "bucket",
        "folder",
        "prefix",
        "query"
      ],
      "properties": {
        "destination": {
          "type": "string",
          "description": "Through what channel to return the Response Broker response",
          "minLength": 2,
          "maxLength": 25,
          "enum": [
            "S3",
            "http(future)"
          ],
          "default": "S3"
        },
        "bucket": {
          "type": "string",
          "description": "When Response Broker destination is S3, the bucket to hold the response",
          "minLength": 0,
          "maxLength": 100,
          "default": "customerbucket"
        },
        "folder": {
          "type": "string",
          "description": "When Response Broker destination is S3, the folder to hold the response",
          "minLength": 0,
          "maxLength": 100,
          "default": "/queryresponse"
        },
        "prefix": {
          "type": "string",
          "description": "When Response Broker destination is S3, the response object prefix to be applied",
          "minLength": 0,
          "maxLength": 100,
          "default": "queryresponse"
        },
        "query": {
          "type": "object",
          "description": "The Query to execute for the response",
          "minLength": 0,
          "maxLength": 15000,
          "default": {
            "Contacts": {
              "contacts": {
                "dataSetId": "xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx",
                "type": "AUDIENCE",
                "pageInfo": {
                  "count": null,
                  "endCursor": null,
                  "startCursor": null,
                  "hasNextPage": null,
                  "hasPreviousPage": null
                },
                "edges": {
                  "node": {
                    "attributes": {
                      "name": null,
                      "value": null,
                      "type": null
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "transforms": {
      "type": "object",
      "description": "Transformations to be applied to the inbound data. These are all Optional, use empty values to not apply the transformation. Options include Audience status, Consent status, unique methods, jsonmapping, csvmapping, and ignore columns",
      "required": [
        "contactid",
        "contactkey",
        "addressablefields",
        "audienceupdate",
        "consent",
        "methods",
        "jsonmap",
        "csvmap",
        "ignore"
      ],
      "properties": {
        "contactid": {
          "type": "string",
          "minLength": 0,
          "description": "Examples:\nContactKey: 123456789          # Static value\nContactKey: $.jsonpathValue    # JSONPath foeserved JSON files\nContactKey: @.csvfileColumn    # Column name for CSV files",
          "default": {
            "contactid": "123456789"
          }
        },
        "contactkey": {
          "type": "string",
          "minLength": 0,
          "description": "Examples: \nContactId: 123456789,        // specify a static value \nContactId: $.jsonpathValue,  // When a JSON datafile, specify a value using JSONPath statement \nContactId: @.csvfileColumn   // When a CSV datafile specify a value from a Column in the data",
          "default": {
            "contactkey": "123456789"
          }
        },
        "addressablefields": {
          "type": "object",
          "description": "Optional, Addressable Fields to use as the key to update a Contact. Where the first param is the Addressable Field Name and the second param is the value to be recorded as the Addressable Field Value\nExamples:\nEmail: abcemail@domain.com          # Static value\nReferenceId: $.jsonpathValue    # JSONPath for JSON files\nUniqueId: @.csvfileColumn      # Column name for CSV files",
          "minLength": 0,
          "maxLength": 3,
          "properties": {
            "field1": {
              "type": "string",
              "minLength": 0,
              "default": {
                "Email": "$.emailAddress"
              }
            },
            "field2": {
              "type": "string",
              "minLength": 0,
              "default": {
                "UniqueId": "@.uniqueIdColumn"
              }
            },
            "field3": {
              "type": "string",
              "minLength": 0,
              "default": {
                "field3": "StaticValue123456789"
              }
            }
          }
        },
        "consent": {
          "type": "object",
          "description": "Optional, Consent(s) and statuses to be mapped from this stream of data (dataflow) where the first param is the Channel Consent Name (Email, SMS, WhatsApp) and the second param is the value to be recorded as the Channel Consent Status (OPT_IN, OPT_OUT, OPT_IN_UNVERIFIED)\nExamples:\nEmail: 123456789          # Static value\nEmail: $.jsonpathValue    # JSONPath for JSON files\nSMS: @.csvfileColumn      # Column name for CSV files",
          "minLength": 0,
          "maxLength": 20,
          "properties": {
            "Email": {
              "type": "string",
              "minLength": 0
            },
            "SMS": {
              "type": "string",
              "minLength": 0
            },
            "WhatsApp": {
              "type": "string",
              "minLength": 0
            },
            "statement": {
              "type": "object",
              "description": "Optional, a pre-Defined Consent Statement to be included in the Consent update. Example: consentGroups: [{\"consentGroupId\": \"97660d76-02d8-5fd6-xxxx-000000000000\", \"status\": \"OPT_IN\"}, {\"consentGroupId\": \"97660d76-02d8-5fd6-xxxx-000000000000\", \"channels\": {\"channel\": \"EMAIL\", \"status\": \"OPT_IN_UNVERIFIED\"}}]"
            }
          },
          "default": {
            "Email": "OPT_IN_UNVERIFIED",
            "SMS": "OPT_IN",
            "WhatsApp": "OPT_OUT",
            "Email2": "$.json_emailchannel2consentvalue",
            "Email3": "@.csvfile_emailchannel3consentvalue"
          }
        },
        "audienceupdate": {
          "type": "object",
          "description": "Optional, Audience(s) and statuses to be associated with this stream of data (dataflow) where the first param is the Audience Name and the second param is the value to be recorded as the Audience Status\nExamples:\nEmail: 123456789          # Static value\nEmail: $.jsonpathValue    # JSONPath for JSON files\nSMS: @.csvfileColumn      # Column name for CSV files",
          "minLength": 0,
          "maxLength": 50,
          "properties": {
            "AudienceXYZ": {
              "type": "string",
              "minLength": 3
            },
            "AudienceABC": {
              "type": "string",
              "minLength": 3
            }
          },
          "default": {
            "AudienceXYZ": "AudienceColumn1",
            "AudienceABC": "$.json_AudienceValue",
            "AudienceDEF": "@.csvfile_AudienceColumn"
          }
        },
        "methods": {
          "type": "object",
          "description": "Transform code for specific transforms. For each Method an empty Value indicates to Not perform the Transformation ie. daydate: \"\".",
          "properties": {
            "daydate": {
              "type": "string",
              "description": "Optional. Add a Column of the Day of the Week (Monday, Tuesday, Wednesday, etc....) based on the defined Column in the data. The Column defined must contain a valid Date value. Leave value(s) empty to not invoke the transform.",
              "minLength": 0
            },
            "date_iso1806_type": {
              "type": "object",
              "description": "Optional. Add a Column of the Day of the Week (Monday, Tuesday, Wednesday, etc.... based on the defined Column in the data. The Column defined must contain a valid Date value. Leave value(s) empty to not invoke the transform.",
              "minLength": 0
            },
            "phone_number_type": {
              "type": "object",
              "description": "Optional. Transform a common format Phone Number String to a Phone-Number Typed string for Connect. Leave value(s) empty to not invoke the transform.",
              "minLength": 0
            },
            "string_to_number_type": {
              "type": "object",
              "description": "Optional. Transform a common string value to a Number typed value for Connect. Leave value(s) empty to not invoke the transform.",
              "minLength": 0
            },
            "method2": {
              "type": "object",
              "description": "Optional. A Placeholder for future Transformation Methods. Leave value(s) empty to not invoke the transform.",
              "minLength": 0
            }
          },
          "required": [
            "daydate",
            "date_iso1806_type",
            "phone_number_type",
            "string_to_number_type"
          ],
          "default": {
            "daydate": "",
            "date_iso1806_type": {
              "": ""
            },
            "phone_number_type": {
              "": ""
            },
            "string_to_number_type": {
              "": ""
            }
          }
        },
        "jsonmap": {
          "type": "object",
          "description": "Optional. Write a New Column with the value from the JSON data, specified using a JSONPath statement. Use a JSONPath editor and a sample of the data to determine the statement needed. Leave value(s) empty to not apply the transform.",
          "properties": {
            "Col1": {
              "type": "string",
              "minLength": 0
            },
            "Col2": {
              "type": "string",
              "minLength": 0
            }
          },
          "default": {
            "NewCol1": "$.JsonProperty1",
            "NewCol2": "$.JSONProp2"
          }
        },
        "default": {
          "audienceupdate": [
            {
              "AudienceX1": "$.audienceColumn1"
            },
            {
              "AudienceX2": "$.audienceColumn2"
            }
          ],
          "channelconsent": [
            {
              "EMAIL": "$.audienceColumn1"
            },
            {
              "SMS": "$.audienceColumn2"
            }
          ],
          "contactkey": "",
          "contactid": ""
        }
      },
      "csvmap": {
        "type": "object",
        "description": "Optional. Write a New Column with the value from the Column of the CSV data. Ie. Replace 'Col1' with the name of the New Column and specify the Column in the data to use as the value of the New Column ('Street1': 'StreetAddress1' creates a new Column Street1 with the value of StreetAddress1).  Leave value(s) empty to not apply the transform.",
        "properties": {
          "Col1": {
            "type": "string",
            "description": "Write a New Column with the value from the Column of the CSV data. Ie. Replace 'Col1' with the name of the New Column and specify the Column in the data to use as the value of the New Column ('Street1': 'StreetAddress1' creates a new Column Street1 with the value of StreetAddress1). Leave value(s) empty to not apply the transform. ",
            "minLength": 1
          },
          "Col2": {
            "type": "string",
            "minLength": 1
          }
        },
        "default": {
          "NewCol1": "ExistingColumn1",
          "NewCol2": "ExistingColumn2"
        }
      },
      "ignore": {
        "type": "array",
        "description": "Optional. Ignore a Column in the data, effectively remove the Column from the data. Ie. 'Col1' will remove the Column Col1 from the data. This action is always performed last so that previous Transformations adding columns can have the source columns removed from the data.  Leave value(s) empty to not apply the transform.",
        "items": {
          "properties": {
            "Col1": {
              "type": "string",
              "minLength": 1
            },
            "Col2": {
              "type": "string",
              "minLength": 1
            }
          }
        },
        "default": [
          {
            "Col1": "",
            "Col2": ""
          }
        ]
      }
    }
  }
}